名称不是对象，名称就是名称
变量是标注，而不是盒子
>>>a = [i for i in range(3)]
>>>b = a
>>>b.append(3)
>>>a
[0, 1, 2, 3]

b = a语句不是把a盒子中的内容复制到b盒子中，而是在标注为a的对象上再贴一个标注b
“把变量s分配给seesaw，而不是把seesaw分配给变量s”，seesaw是一个对象

动词“分配”自相矛盾，经常使用“绑定”代替。在Python中，赋值语句x = ...把名称x绑定到右边创建或引用的对象上。
在绑定名称之前，对象必须存在。


同一性，相等性和别名：
>>> charles = {'name': 'Charles L. Dodgson', 'born': 1832}
>>> lewis = charles
>>> lewis is charles
True
>>> id(charles), id(lewis)
(4300473992, 4300473992)
>>> lewis['balance'] = 950
>>> charles
{'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}
>>> alex = {'name': 'Charles L. Dodgson', 'born': 1832}

alex指代的对象与分配给charles的对象内容一样，但它们是不同的对象，在Python中，使用a is not b判断两个对象的标识是否不同
lewis和charles是别名，即两个变量绑定同一个对象。而alex不是charles的别名，因为二者绑定的是不同的对象。alex和
charles绑定的对象具有相同的值（==比较的是值），但是它们的标识不同
对象一旦创建，标识始终（内存地址）不变，is运算符比较两个对象的标识，id()函数返回对象标识的整数表示


==运算符比较两个对象的值（对象存储的数据），而is比较对象的标识
比较一个变量和一个单例时，应该使用is。一般来说，is运算符只用于测试None
哨符对象也是单例，同样使用is测试


元组的相对不可变性：
元组与多数 Python 容器（列表、字典、集合等）一样，存储的是对象的引用。 如果引用的项是可变的，即便元组本身不可变，项依然可以
更改。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即存储的引用）不可变，与引用的对象无关。


默认做浅拷贝：
复制列表（或多数内置的可变容器）最简单的方式是使用内置的类型构造函数。
>>> l1 = [1, 2]
>>> l2 = list(l1)
>>> l1 is l2
False

>>> l3 = l1[:]
>>> l1 is l3
False

>>> t1 = (1, 2, )
>>> t2 = tuple(t1)
>>> t1 is t2
True

构造函数或[:]做的是浅拷贝

列表和元组行为不同的原因：
列表是可变的，元组是不可变的。列表必须保证独立性，元组为了性能而重用
为了保证每个列表实例的修改互不影响，list()构造函数每次都会分配一块新的内存空间
既然元组无法被修改，那么在内存中保留两个内容完全相同的元组其实是一种浪费

>>> a = [1, [2, 3], (4, 5)]
>>> b = list(a)
>>> a is b
False
>>> a[2] is b[2]
True
>>> a[2] += (6, 7)
>>> a
[1, [2, 3], (4, 5, 6, 7)]
>>> b
[1, [2, 3], (4, 5)]
>>> c = (1, 2)
>>> id(c)
1814392557376
>>> c += (3, 4)
>>> id(c)
1814393766272

上述行为：
元组使用+=时会创建新对象，重新赋值引用，因为元组是不可变的
列表使用+=时会在原对象上直接修改，因为列表是可变的


为任意对象做浅拷贝和深拷贝
浅拷贝通常来说没什么问题，但有时我们需要的是深拷贝（即副本不共享内部对象的引用）。
copy 模块提供的 copy 和 deepcopy 函数分别对任意对象做浅拷贝和深拷贝。

例：
class Bus:
    def __init__(self, passengers=None):
        if passengers is None:
            self.passengers = []
        else:
            self.passengers = list(passengers)

    def pick(self, name):
        self.passengers.append(name)

    def drop(self, name):
        self.passengers.remove(name)


>>> import copy
>>> bus1 = Bus(['Alice', 'Bill', 'Claire', 'David'])
>>> bus2 = copy.copy(bus1)
>>> bus3 = copy.deepcopy(bus1)
>>> id(bus1), id(bus2), id(bus3)
(4301498296, 4301499416, 4301499752)
>>> bus1.drop('Bill')
>>> bus2.passengers
['Alice', 'Claire', 'David']
>>> id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)
(4302658568, 4302658568, 4302657800)
>>> bus3.passengers
['Alice', 'Bill', 'Claire', 'David']


函数的参数时引用时：
共享传参指函数的形参获得实参引用的副本。也就是说，函数内部的形参是实参的别名
不要使用可变类型作为函数的默认值
防御可变参数


del和垃圾回收：
del不是函数而是语句，写作del x，而不是del(x)

其次，del语句删除引用，而不是对象。del可能导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用时。
重新绑定也可能导致对象的引用数量归零，致使对象被销毁
>>> a = [1, 2]
>>> b = a
>>> del a    
>>> b
[1, 2]
>>> b = [3]

列表[1, 2]被销毁了

在 CPython 中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数
归零时，对象立即被销毁：CPython 在对象上调用 __del__ 方法（如果定义了），然后释放分配给对象的内存。

>>> import weakref
>>> s1 = {1, 2, 3}
>>> s2 = s1        
>>> def bye():
...     print('...like tears in the rain.') 
... 
>>> ender = weakref.finalize(s1, bye)
>>> ender.alive
True
>>> del s1
>>> ender.alive
True
>>> s2 = 'spam'
...like tears in the rain. 
>>> ender.alive
False

s1 和 s2 是别名，指向同一个集合 {1, 2, 3}。
这个函数一定不能是要销毁的对象的绑定方法，否则会有一个指向对象的引用。
在 s1 引用的对象上注册 bye 回调。
调用 finalize 对象之前，.alive 属性的值为 True。
如前所述，del 不删除对象，而是删除对象的引用 s1。
重新绑定最后一个引用 s2，让 {1, 2, 3} 不可达。对象被销毁
了，调用了 bye 回调，ender.alive 的值变成了 False。

上述示例的目的是明确指出 del 不删除对象，但是执行 del 操作后
可能会导致对象不可达，从而使得对象被删除。



















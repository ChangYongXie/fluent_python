名称不是对象，名称就是名称
变量是标注，而不是盒子
>>>a = [i for i in range(3)]
>>>b = a
>>>b.append(3)
>>>a
[0, 1, 2, 3]

b = a语句不是把a盒子中的内容复制到b盒子中，而是在标注为a的对象上再贴一个标注b
“把变量s分配给seesaw，而不是把seesaw分配给变量s”，seesaw是一个对象

动词“分配”自相矛盾，经常使用“绑定”代替。在Python中，赋值语句x = ...把名称x绑定到右边创建或引用的对象上。
在绑定名称之前，对象必须存在。


同一性，相等性和别名：
>>> charles = {'name': 'Charles L. Dodgson', 'born': 1832}
>>> lewis = charles
>>> lewis is charles
True
>>> id(charles), id(lewis)
(4300473992, 4300473992)
>>> lewis['balance'] = 950
>>> charles
{'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}
>>> alex = {'name': 'Charles L. Dodgson', 'born': 1832}

alex指代的对象与分配给charles的对象内容一样，但它们是不同的对象，在Python中，使用a is not b判断两个对象的标识是否不同
lewis和charles是别名，即两个变量绑定同一个对象。而alex不是charles的别名，因为二者绑定的是不同的对象。alex和
charles绑定的对象具有相同的值（==比较的是值），但是它们的标识不同
对象一旦创建，标识始终（内存地址）不变，is运算符比较两个对象的标识，id()函数返回对象标识的整数表示


==运算符比较两个对象的值（对象存储的数据），而is比较对象的标识
比较一个变量和一个单例时，应该使用is。一般来说，is运算符只用于测试None
哨符对象也是单例，同样使用is测试


元组的相对不可变性：
元组与多数 Python 容器（列表、字典、集合等）一样，存储的是对象的引用。 如果引用的项是可变的，即便元组本身不可变，项依然可以
更改。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即存储的引用）不可变，与引用的对象无关。


默认做浅拷贝：
复制列表（或多数内置的可变容器）最简单的方式是使用内置的类型构造函数。
>>> l1 = [1, 2]
>>> l2 = list(l1)
>>> l1 is l2
True

>>> l3 = l1[:]
>>> l1 is l3
True

>>> t1 = (1, 2, )
>>> t2 = tuple(t1)
>>> t1 is t2
True

构造函数或[:]做的是浅拷贝

列表和元组行为不同的原因：
列表是可变的，元组是不可变的。列表必须保证独立性，元组为了性能而重用
为了保证每个列表实例的修改互不影响，list()构造函数每次都会分配一块新的内存空间
既然元组无法被修改，那么在内存中保留两个内容完全相同的元组其实是一种浪费

>>> a = [1, [2, 3], (4, 5)]
>>> b = list(a)
>>> a is b
False
>>> a[2] is b[2]
True
>>> a[2] += (6, 7)
>>> a
[1, [2, 3], (4, 5, 6, 7)]
>>> b
[1, [2, 3], (4, 5)]
>>> c = (1, 2)
>>> id(c)
1814392557376
>>> c += (3, 4)
>>> id(c)
1814393766272

上述行为：
元组使用+=时会创建新对象，重新赋值引用，因为元组是不可变的
如果时列表使用+=时会在原对象上直接修改，因为列表是可变的



















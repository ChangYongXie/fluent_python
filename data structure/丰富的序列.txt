内置序列类型：
容器序列（可存放不同类型的项，其中包括嵌套容器），容器序列存放的是所包含对象的引用
扁平序列（不能内部嵌套的序列），扁平序列存放的是所含内容的值。扁平序列更加紧凑，但是只能存放原始机器值

按可变性分类：
可变序列（继承不可变序列的所有方法，还多实现了几个方法）
不可变序列

issubclass()
isinstance()

列表推导式：
square = [i**2 for i in range(1, 10)]
生成器表达式：
(i**2 for i in range(1, 10))，占用的内存比列表推导式更少

for字句中赋值的变量在局部作用域内，使用“海象运算符”:=赋值的变量在推导式或生成器表达式返回后依然可以访问

filter()和map()
lambda表达式


元组不仅仅是不可变列表
用作记录：

lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)

traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567')
 ('ESP', 'XDA205856')] 

for passport in sorted(traveler_ids): 
...     print('%s/%s' % passport)
...
BRA/CE342567
ESP/XDA205856
USA/31195855

for country, _ in traveler_ids:
...     print(country)
... 
USA
BRA
ESP

元组拆包
_表示虚拟变量，有效。在match case语句中为通配符，可出现多次。匹配值但不绑定值
拆包对可迭代对象的唯一要求是一次只能产出一项，提供给接收端变量（并行赋值）。不过也有例外，可以使用星号(*)捕获余下的项
定义函数是可以使用*args（返回一个列表）捕获余下的任意数量的参数。并行赋值时，*前缀只能应用到一个变量上，可以是任何位置

嵌套拆包：
pass


用作不可变列表：

优点：长度永不可变，占用内存更少
但元组的不可变性仅针对元组中的引用而言。元组中的引用不可删除，不可替换。
倘若引用的是可变对象，改动对象之后，元组的值也会随之变化

只有值永不可变的对象才是可哈希的。不可哈希的元组不能作为字典的键，也不能作为集合的元素

divmod()函数，同时计算两个数的商和余数


match case嵌套拆包：

metro_areas = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), 
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), 
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), 
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), 
    ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), 
]
def main():
    print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
    for record in metro_areas:
        match record:
            case [name, _, _, (lat, lon)] if lon <= 0:
                print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')

case子句后可跟卫语句
模式中的任何一部分均可使用 as 关键字绑定到变量上

一般来说，匹配对象同时满足以下条件方能匹配序列模式。
01. 匹配对象是序列。
02. 匹配对象和模式的项数相等。
03. 对应的项相互匹配，包括嵌套的项

match/case语句不处理str，bytes，bytearray
添加类型信息可以让模式更具体。
 case [str(name), _, _, (float(lat), float(lon))]:


切片：
seq[start:stop:step]，step指定步长，可为负数

切片对象：
class 'slice'
代码示例：

>>> invoice = """ 
... 0.....6.................................40........52...55........ 
... 1909  Pimoroni PiBrella                     $17.50    3    $52.50 
... 1489  6mm Tactile Switch x20                 $4.95    2     $9.90 
... 1510  Panavise Jr. - PV-201                 $28.00    1    $28.00 
... 1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95 
... """ 
>>> SKU = slice(0, 6) 
>>> DESCRIPTION = slice(6, 40) 
>>> UNIT_PRICE = slice(40, 52) 
>>> QUANTITY =  slice(52, 55) 
>>> ITEM_TOTAL = slice(55, None) 
>>> line_items = invoice.split('\n')[2:] 
>>> for item in line_items: 
...     print(item[UNIT_PRICE], item[DESCRIPTION]) 
... 
    $17.50   Pimoroni PiBrella 
     $4.95   6mm Tactile Switch x20 
    $28.00   Panavise Jr. - PV-201 
    $34.95   PiTFT Mini Kit 320x24



内置序列的多维切片：
>>>my_l = [
[1, 2, 3], 
[4, 5, 6], 
]

>>>print(my_l[1][1])
...5


Numpy的多维切片：

>>>import numpy as np

# 创建一个 4x5 的数组
>>>arr = np.array([[1, 2, 3, 4, 5],
                [6, 7, 8, 9, 10],
                [11, 12, 13, 14, 15],
                [16, 17, 18, 19, 20]])

>>>print(arr[1:3, :])  # 第1到第2行（不包括第3行），所有列
>>>print(arr[:, 2:4]) # 所有行，第2到第4列

省略号用于表示"所有剩余维度"。

>>>import numpy as np
>>> arr_3d = np.arange(24).reshape(2, 3, 4)
>>> arr_3d
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>>print(arr_3d[..., 0]) # 所有维度的第一个元素
>>>print(arr_3d[0, ...]) # 第一维的所有元素
>>>print(arr_3d[..., 1:3])  # 所有维的第二到第三个元素






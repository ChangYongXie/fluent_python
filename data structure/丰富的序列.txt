内置序列类型：
容器序列（可存放不同类型的项，其中包括嵌套容器），容器序列存放的是所包含对象的引用
扁平序列（不能内部嵌套的序列），扁平序列存放的是所含内容的值。扁平序列更加紧凑，但是只能存放原始机器值

*一些对象包含对其他对象的引用，这种对象称为容器

按可变性分类：
可变序列（继承不可变序列的所有方法，还多实现了几个方法）
不可变序列

issubclass()
isinstance()

列表推导式：
square = [i**2 for i in range(1, 10)]
生成器表达式：
(i**2 for i in range(1, 10))，占用的内存比列表推导式更少

for字句中赋值的变量在局部作用域内，使用“海象运算符”:=赋值的变量在推导式或生成器表达式返回后依然可以访问

filter()和map()
lambda表达式


元组不仅仅是不可变列表
用作记录：

lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)

traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567')
 ('ESP', 'XDA205856')] 

for passport in sorted(traveler_ids): 
...     print('%s/%s' % passport)
...
BRA/CE342567
ESP/XDA205856
USA/31195855

for country, _ in traveler_ids:
...     print(country)
... 
USA
BRA
ESP

元组拆包
_表示虚拟变量，有效。在match case语句中为通配符，可出现多次。匹配值但不绑定值
拆包对可迭代对象的唯一要求是一次只能产出一项，提供给接收端变量（并行赋值）。不过也有例外，可以使用星号(*)捕获余下的项
定义函数是可以使用*args（返回一个列表）捕获余下的任意数量的参数。并行赋值时，*前缀只能应用到一个变量上，可以是任何位置

嵌套拆包：
pass


用作不可变列表：

优点：长度永不可变，占用内存更少
但元组的不可变性仅针对元组中的引用而言。元组中的引用不可删除，不可替换。
倘若引用的是可变对象，改动对象之后，元组的值也会随之变化

只有值永不可变的对象才是可哈希的。不可哈希的元组不能作为字典的键，也不能作为集合的元素

divmod()函数，同时计算两个数的商和余数


match case嵌套拆包：

metro_areas = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), 
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), 
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), 
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), 
    ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), 
]
def main():
    print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
    for record in metro_areas:
        match record:
            case [name, _, _, (lat, lon)] if lon <= 0:
                print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')

case子句后可跟卫语句
模式中的任何一部分均可使用 as 关键字绑定到变量上

一般来说，匹配对象同时满足以下条件方能匹配序列模式。
01. 匹配对象是序列。
02. 匹配对象和模式的项数相等。
03. 对应的项相互匹配，包括嵌套的项

match/case语句不处理str，bytes，bytearray
添加类型信息可以让模式更具体。
 case [str(name), _, _, (float(lat), float(lon))]:


切片：
seq[start:stop:step]，step指定步长，可为负数

切片对象：
class 'slice'
代码示例：

>>> invoice = """ 
... 0.....6.................................40........52...55........ 
... 1909  Pimoroni PiBrella                     $17.50    3    $52.50 
... 1489  6mm Tactile Switch x20                 $4.95    2     $9.90 
... 1510  Panavise Jr. - PV-201                 $28.00    1    $28.00 
... 1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95 
... """ 
>>> SKU = slice(0, 6) 
>>> DESCRIPTION = slice(6, 40) 
>>> UNIT_PRICE = slice(40, 52) 
>>> QUANTITY =  slice(52, 55) 
>>> ITEM_TOTAL = slice(55, None) 
>>> line_items = invoice.split('\n')[2:] 
>>> for item in line_items: 
...     print(item[UNIT_PRICE], item[DESCRIPTION]) 
... 
    $17.50   Pimoroni PiBrella 
     $4.95   6mm Tactile Switch x20 
    $28.00   Panavise Jr. - PV-201 
    $34.95   PiTFT Mini Kit 320x24



内置序列的多维切片：
>>>my_l = [
[1, 2, 3], 
[4, 5, 6], 
]

>>>print(my_l[1][1])
...5


Numpy的多维切片：

>>>import numpy as np

# 创建一个 4x5 的数组
>>>arr = np.array([[1, 2, 3, 4, 5],
                [6, 7, 8, 9, 10],
                [11, 12, 13, 14, 15],
                [16, 17, 18, 19, 20]])

>>>print(arr[1:3, :])  # 第1到第2行（不包括第3行），所有列
>>>print(arr[:, 2:4]) # 所有行，第2到第4列

省略号用于表示"所有剩余维度"。

>>>import numpy as np
>>> arr_3d = np.arange(24).reshape(2, 3, 4)
>>> arr_3d
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>>print(arr_3d[..., 0]) # 所有维度的第一个元素
>>>print(arr_3d[0, ...]) # 第一维的所有元素
>>>print(arr_3d[..., 1:3])  # 所有维的第二到第三个元素

*例子（重要）：

import numpy as np



a = np.arange(2*3*4*5).reshape(2, 3, 4, 5)
print(a)

[[[[  0   1   2   3   4]
   [  5   6   7   8   9]
   [ 10  11  12  13  14]
   [ 15  16  17  18  19]]

  [[ 20  21  22  23  24]
   [ 25  26  27  28  29]
   [ 30  31  32  33  34]
   [ 35  36  37  38  39]]

  [[ 40  41  42  43  44]
   [ 45  46  47  48  49]
   [ 50  51  52  53  54]
   [ 55  56  57  58  59]]]


 [[[ 60  61  62  63  64]
   [ 65  66  67  68  69]
   [ 70  71  72  73  74]
   [ 75  76  77  78  79]]

  [[ 80  81  82  83  84]
   [ 85  86  87  88  89]
   [ 90  91  92  93  94]
   [ 95  96  97  98  99]]

  [[100 101 102 103 104]
   [105 106 107 108 109]
   [110 111 112 113 114]
   [115 116 117 118 119]]]]


这是一个四维数组，表示一个数组里有2个元素，这两个元素里各有3个元素，这三个元素里各有4个元素，这四个元素里各有5个元素
所以a[:1, :1, 1:2, 2:3]的结果为[[[[7]]]] 
第一个索引 表示 整个数组 的 第一个元素
第二个索引 表示 整个数组 的 第一个元素的第一个元素
第三个索引 表示 整个数组 的 第一个元素的第一个元素的第二个元素
第四个索引 表示 整个数组 的 第一个元素的第一个元素的第二个元素的第三个元素

a[:1, ...]，...表示余下所有维度，...是Ellipsis对象的别名，而Ellipsis对象是ellipsis类的单例


为切片赋值
>>> l = list(range(10)) 
>>> l 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
>>> l[2:5] = [20, 30] 
>>> l 
[0, 1, 20, 30, 5, 6, 7, 8, 9] 
>>> del l[5:7] 
>>> l 
[0, 1, 20, 30, 5, 8, 9] 
>>> l[3::2] = [11, 22] 
>>> l 
[0, 1, 20, 11, 5, 22, 9] 
>>> l[2:5] = 100  ❶ 
Traceback (most recent call last): 
    File "<stdin>", line 1, in <module> 
TypeError: can only assign an iterable 
>>> l[2:5] = [100] 
>>> l 
[0, 1, 100, 22, 9]

❶ 如果赋值目标是一个切片，则右边必须是一个可迭代对象，即使只有
一项。


使用*初始化嵌套列表的陷阱（浅拷贝陷阱）


背后支持+=运算符的是魔法方法__iadd__（就地相加）


如果 a 实现了 __iadd__，那就调用它。如果 a 是可变序列（例如，
list、bytearray、array.array），则就地修改 a（行为类似于
a.extend(b)）。倘若 a 没有实现 __iadd__ 方法，表达式 a +=
b 的作用等同于 a = a + b，先求解表达式 a + b，再把得到的新对
象绑定到 a 上。也就是说，a 绑定的对象身份可能变了，也可能没变，
这取决于有没有实现 __iadd__ 方法


list.sort()方法就地排序列表，不创建副本，返回值为None
就地更改对象的函数或方法应该返回None
内置函数sorted(seq)返回创建的新列表



list.sort 和 sorted 均接受两个可选的关键字参数。
reverse
　　值为 True 时，降序返回项（即反向比较各项）。默认值为
False。

key
　　一个只接受一个参数的函数，应用到每一项上，作为排序依据。例
如，排序字符串时，key=str.lower 执行不区分大小写排序，而
key=len 按字符长度排序各个字符串。默认值是恒等函数（即比较项本
身）。

min()和 max() 等内置函数，以及标准库中的其他函数
（例如 itertools.groupby() 和 heapq.nlargest()）也有
可选的关键字参数 key。


可以取代列表的可变序列类型：
数组
memoryview，memoryview是一种共享内存的序列类型
双端队列，deque

无论基因上是否100%是鸭子，但是都应该嘎嘎叫；如果元组中的每一项都是一个字段，那么每个字段就可以具有不同的类型



















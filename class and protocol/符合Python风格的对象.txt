得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是
鸭子类型：只需按照预定行为实现对象所需的方法即可

本章内容：
1. 把对象转换成其他类型的内置函数（例如 repr()、bytes()、complex() 等）；
2. 通过一个类方法实现备选构造函数；
3. 扩展 f 字符串、内置函数 format() 和 str.format() 方法使用的格式化微语言；
4. 实现只读属性；
5. 把对象变为可哈希的，以便在集合中及作为 dict 的键使用；
6. 利用 __slots__ 节省内存。


对象表示形式
每门面向对象语言至少都有一种获取对象字符串表示形式的标准方式。Python 提供了两种方式。repr()和str()
除此之外，还有两个特殊方法（__bytes__ 和 __format__）可为对象提供其他表示形式。__bytes__ 方法与 __str__ 方法类似，
bytes() 函数调用它获取对象的字节序列表示形式。而 __format__方法供 f 字符串、内置函数 format() 和 str.format() 方法使
用，通过调用 obj.__format__(format_spec) 以特殊的格式化代码显示对象的字符串表示形式。

备选构造函数
@classmethod装饰器，定义操作类的方法，而不是操作实例
@staticmethod装饰器，静态方法就是普通的函数

格式化显示
f 字符串、内置函数 format() 和 str.format() 方法会把各种类型的格式化方式委托给相应的 .__format__(format_spec) 方法。format_spec 是格式说明符
例：
>>> brl = 1 / 4.82  # 巴西雷亚尔兑换美元的汇率
>>> brl
0.20746887966804978
>>> format(brl, '0.4f')
'0.2075'
>>> '1 BRL = {rate:0.2f} USD'.format(rate=brl)
'1 BRL = 0.21 USD'
>>> f'1 USD = {1 / brl:0.2f} BRL'
'1 USD = 4.82 BRL'

格式规范微语言为一些内置类型提供了专用的表示代码。例如，b 和 x分别表示二进制和十六进制的 int 类型，f 表示小数形式的 float类型，而 % 表示百分数形式。
>>> format(42, 'b')
'101010'
>>> format(2 / 3, '.1%')
'66.7%'

可哈希
使用两个前导下划线把属性标记为私有
私有属性的名称会被“改写”，在前面加上_和类名。它的目的是避免意外访问，不能防止意外做错事
例：
>>> v1 = Vector2d(3, 4)
>>> v1.__dict__
{'_Vector2d__y': 4.0, '_Vector2d__x': 3.0}
>>> v1._Vector2d__x
3.0

@property装饰器把读值方法标记为特性

支持位置模式匹配
为了让类支持位置模式，需要添加一个名为__match_args__的类属性，按照在位置模式匹配中的顺序理出实例属性

使用__slots__节省空间
默认情况下，Python 把各个实例的属性存储在一个名为 __dict__ 的字典中。3.9 节讲过，字典消耗的内存很多——即使有一些优化措施。
但是，如果定义一个名为 __slots__ 的类属性，以序列的形式存储属性名称，那么 Python 将使用其他模型存储实例属性：__slots__ 中
的属性名称存储在一个隐藏的引用数组中，消耗的内存比字典少。

定义__slots__属性的类没有__dict__属性，不能为不在__slots__中的属性赋值
子类只继承__slots__的部分效果，为了确保子类也没有__dict__属性，必须在子类中再次定义__slots__属性
如果在子类中声明 __slots__ = ()（一个空元组），则子类的实例将没有 __dict__ 属性，而且只接受基类的 __slots__ 属性列出的属性名称。
如果子类需要额外属性，则在子类的__slots__属性中列出来
例：
class ColorPixel(Pixel):
      __slots__ = ('color', )

如果使用得当，则类属性 __slots__ 能显著节省内存，不过有几个问题需要注意。
1. 每个子类都要重新声明 __slots__ 属性，以防止子类的实例有__dict__ 属性。
2. 实例只能拥有 __slots__ 列出的属性，除非把 '__dict__' 加入 __slots__ 中（但是这样做就失去了节省内存的功效）。
3. 有 __slots__ 的类不能使用 @cached_property 装饰器，除非把 '__dict__' 加入 __slots__ 中。
4. 如果不把 '__weakref__' 加入 __slots__ 中，那么实例就不能作为弱引用的目标。


覆盖类属性
类属性可为实例属性提供默认值。
如果为不存在的实例属性赋值，那么将创建一个新实例属性。假如为 typecode 实例属性赋值，那么同名类属性将不受影响。然而，一
旦这样做，实例读取的 self.typecode 是实例属性 typecode，也就是把同名类属性遮盖了。借助这个功能，可以为各个实例的
typecode 属性定制不同的值。
例：
>>> class Pixel:
              z = 1
...           def __init__(self):
...                 self.x = 1
...                 self.y = 2
...
>>> p = Pixel()
>>> p.__dict__
{'x': 1, 'y': 2}
>>> p.z = 3
>>> p.__dict__
{'x': 1, 'y': 2, 'z': 3}

如果想修改类属性的值，那么必须直接在类上修改，不能通过实例修改。如果想修改所有实例（自身没有 typecode 属性）的 typecode
属性的默认值，则可以像下面这样做。
>>> Vector2d.typecode = 'f'

子类覆盖类属性
例：
class SubPixel(Pixel):
...    z = 9
...








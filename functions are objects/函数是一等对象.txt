在 Python 中，函数是一等对象。编程语言研究人员把“一等对象”定义为满足以下条件的程序实体：
*在运行时创建；
*能赋值给变量或数据结构中的元素；
*能作为参数传给函数；
*能作为函数的返回结果。


把函数视为对象
可以把函数赋值给变量，然后通过变量名调用。还可以把函数作为参数传递给map()，filter()等函数


高阶函数
接受函数为参数或者把函数作为结果返回的函数是高阶函数，如map()，sorted()函数 等

map()，filter()和reduce()的现代替代品
列表推导式或生成器表达式兼具map()和filter()这两个函数的功能，而且代码可读性更高
sum()和reduce()的整体运作方式是一样的，即把某个操作连续应用到序列中的项上，累计前一个结果，把一系列值规约成一个值
例：
>>> reduce(add, range(100))
4950
>>> sum(range(100))
4950

内置规约函数还有all()和any()
all(iterable)
iterable 中没有表示假值的元素时返回 True。all([]) 返回True。
any(iterable)
只要 iterable 中有元素是真值就返回 True。any([]) 返回False。


匿名函数
lambda 关键字使用 Python 表达式创建匿名函数。
然而，受 Python 简单的句法限制，lambda 函数的主体只能是纯粹的表达式。也就是说，lambda 函数的主体中不能有 while、try 等
Python 语句。使用 = 赋值也是一种语句，不能出现在 lambda 函数的主体中。可以有新出现的 := 赋值表达式。不过，有这种赋值表达式的
lambda 函数可能太过复杂，可读性低，因此建议重构，改成使用 def定义的常规函数。

例：
使用lambda表达式重写sorted()函数key参数的reversed()函数
>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana'] 
>>> sorted(fruits, key=lambda word: word[::-1]) 
['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry'] 


9种可调用对象
1.用户定义的函数
2.内置函数
3.方法
4.类的实例
5.生成器函数
6.原生协程函数
7.异步生成器函数

Python中有各种各样的可调用类型。判断对象是否可调用，最安全的方法是使用内置函数callable()


用户定义的可调用类型
不仅 Python 函数是真正的对象，而且任何 Python 对象都可以表现得像函数。为此，只需实现实例方法 __call__。
例：
import random
 
class BingoCage:
 
    def __init__(self, items):
        self._items = list(items)
        random.shuffle(self._items)
 
    def pick(self):
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError('pick from empty BingoCage')
 
    def __call__(self):
        return self.pick()

bingo() (BingoCage的实例) 是bingo.pick的快捷方式


*从位置参数到仅限关键字参数（Python为声明函数形参和传入实参所提供的强大句法）
Python 函数最好的功能之一是提供了极为灵活的参数处理机制。与之密切相关的是，调用函数时可以使用 * 和 ** 拆包可迭代对象，映射各个
参数。
例：
def tag(name, *content, class_=None, **attrs):
    """生成一个或多个HTML标签"""
    if class_ is not None:
        attrs['class'] = class_
    attr_pairs = (f' {attr}="{value}"' for attr, value
                    in sorted(attrs.items()))
    attr_str = ''.join(attr_pairs)
    if content:
        elements = (f'<{name}{attr_str}>{c}</{name}>'
                    for c in content)
        return '\n'.join(elements)
    else:
        return f'<{name}{attr_str} />'

仅限关键字参数是 Python 3 新增的功能。在上述代码中，class_ 参数只能通过关键字参数指定，它一定不会捕获无名位置参数。定义函数
时，如果想指定仅限关键字参数，就要把它们放到前面有 * 的参数后面。如果不想支持数量不定的位置参数，但是想支持仅限关键字参数，
则可以在签名中放一个 *，如下所示。
>>> def f(a, *, b):
...     return a, b
...
>>> f(1, b=2)
(1, 2)
>>> f(1, 2)
Traceback (most recent call last): 
  File "<stdin>", line 1, in <module> 
TypeError: f() takes 1 positional argument but 2 were given

注意，仅限关键字参数不一定要有默认值，可以像上例中的 b 那样，强制要求传入实参。

仅限位置参数
从 Python 3.8 开始，用户定义的函数签名可以指定仅限位置参数。内置函数都是如此，例如 divmod(a, b) 只能使用位置参数调用，不能
写成 divmod(a=10, b=4)。
如果想定义只接受位置参数的函数，则可以在参数列表中使用 /。
例：
def divmod(a, b, /): 
    return (a // b, a % b)
/ 左边均是仅限位置参数。在 / 后面，可以指定其他参数，处理方式一同往常。


支持函数式编程的包
operator模块：
operator 模块为多个算术运算符提供了对应的函数，无须再动手编写像 lambda a, b: a*b 这样的匿名函数。
例：
>>> from functools import reduce 
>>> from operator import mul 
>>> def factorial(n): 
              return reduce(mul, range(1, n+1))

operator 模块中还有一类函数，即工厂函数 itemgetter 和attrgetter，能替代从序列中取出项或读取对象属性的 lambda 表达式。
例：
>>> from operator import itemgetter
>>> city = [
('Tokyo', 'JP', 36.933, (35.689772, 139.691667)), 
('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), 
]
>>> sort_city = sorted(city, key=itemgetter(1))
>>> sort_city
[
('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), 
('Tokyo', 'JP', 36.933, (35.689772, 139.691667)), 
]

代码itemgetter(1)等同于lambda fields: fields[1]

如果传给 itemgetter 多个索引参数，那么 itemgetter 构建的函数就会返回提取的值构成的元组，以方便根据多个键排序。
例：
>>> metro_data = [
('Tokyo', 'JP', 36.933, (35.689772, 139.691667)), 
('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), 
]
>>> cc_name = itemgetter(1, 0) 
>>> for city in metro_data: 
...           print(cc_name(city)) 
...
('JP', 'Tokyo') 
('IN', 'Delhi NCR') 
itemgetter 使用 [] 运算符，因此它不仅支持序列，还支持映射和任何实现 __getitem__ 方法的类。

与 itemgetter 的作用类似，attrgetter 创建的函数会根据名称来提取对象的属性。如果传给 attrgetter 多个属性名，那么它也会返
回由提取的值构成的元组。此外，如果参数名中包含 .（点号），那么attrgetter 就会深入嵌套对象，检索属性。
例：
>>> from collections import namedtuple
>>> LatLon = namedtuple('LatLon', 'lat lon')
>>> Metropolis = namedtuple('Metropolis', 'name cc pop coord')
>>> metro_areas = [Metropolis(name, cc, pop, LatLon(lat, lon)) for name, cc, pop, (lat, lon) in metro_data]
>>> metro_areas[0]
Metropolis(name='Tokyo', cc='JP', pop=36.933, coord=LatLon(lat=35.689722, lon=139.691667))
>>> metro_areas[0].coord.lat
35.689722
>>> from operator import attrgetter
>>> name_lat = attrgetter('name', 'coord.lat')
>>> 
>>> for city in sorted(metro_areas, key=attrgetter('coord.lat')):
...           print(name_lat(city))
... 
('São Paulo', -23.547778) 
('Mexico City', 19.433333) 
('Delhi NCR', 28.613889) 
('Tokyo', 35.689722) 
('New York-Newark', 40.808611)

attrgetter()函数相当于字典

methodcaller()创建的函数会在对象上调用参数指定的方法
例：
>>> from operator import methodcaller 
>>> s = 'The time has come' 
>>> upcase = methodcaller('upper') 
>>> upcase(s) 
'THE TIME HAS COME' 
>>> hyphenate = methodcaller('replace', ' ', '-') 
>>> hyphenate(s) 
'The-time-has-come'

例：
>>> s = 'hello'
>>> s.upper()
'HELLO'
>>> str.upper(s)
'HELLO'
>>> from operator import methodcaller
>>> a = methodcaller('upper')
>>> a(s)
'HELLO'

3中”方法“都可以大写s


partial()，它可以根据提供的可调用对象产生一个新可调用对象，为原可调用对象的某些参数绑定预定的值。使用这个函数可以把接受一
个或多个参数的函数改造成需要更少参数的回调的 API。
例：
>>> from operator import mul
>>> from functools import partial
>>> triple = partial(mul, 3)
>>> triple(7)
21
>>> list(map(triple, range(1, 10)))
[3, 6, 9, 12, 15, 18, 21, 24, 27]
例2：
>>> import unicodedata, functools
>>> nfc = functools.partial(unicodedata.normalize, 'NFC')
>>> s1 = 'café'
>>> s2 = 'cafe\u0301'
>>> s1, s2
('café', 'café')
>>> s1 == s2
False
>>> nfc(s1) == nfc(s2)
True
















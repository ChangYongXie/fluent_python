Python 仍是一门动态类型语言，作者并不意图强制使用类型提示，这只是一种约定


渐进式类型系统
渐进式类型系统具有以下性质：
1.类型注解是可选的。没有类型提示的代码，会假定其为Any类型
2.不在运行时捕获类型错误。在运行时不能阻止把不一致的值传给函数获分配给变量
3.不能改善性能

静态类型系统（强制类型提示，如C）


@pytest.mark.parametrize装饰器
@pytest.mark.parametrize是 Pytest 框架中一个非常强大且常用的装饰器，用于对同一个测试函数实现
多组参数的参数化测试，避免了为只有数据不同的测试场景编写重复代码
例：
@pytest.mark.parametrize("input, expected", [
    ("hello", 5),
    ("", 0),
    ("python", 6)
])
def test_string_length(input, expected):
      assert len(input) == expected


编写类型提示时建议遵守以下代码风格。
参数名称和 : 之间不留空格，: 后加一个空格。
参数默认值前面的 = 两侧加空格。


使用None表示默认值
如果想把 plural 参数的默认值设为 None，则函数签名要改成下面这样。
from typing import Optional 
def show_count(count: int, singular: str, plural: Optional[str] = None) -> str:

Optional[str] 表示 plural 的值可以是一个 str 或 None。
必须显式地提供默认值，即 = None。如果不为 plural 分配默认值，则 Python 运行时将把它视作必需的参
数。记住，类型提示在运行时会被忽略


类型由受支持的操作定义
实践中，最好把受支持的操作当作类型的关键特征。
例：
from collections import abc
def double(x: abc.Sequence):
      return x * 2
类型检查工具将拒绝接受这段代码。如果告诉 Mypy，x 是abc.Sequence 类型，那么 Mypy 在遇到 x　*　2 时将报错，因为抽
象基类 Sequence 没有实现或继承 __mul__ 方法。在运行时，这段代码既能成功处理 str、tuple、list、array 等具体的序列，也能
处理数值，因为类型提示在运行时会被忽略。但是，类型检查工具只关注显式声明的类型，而 abc.Sequence 没有 __mul__ 方法。

在渐进式类型系统中，以下两种对类型的解读相互影响着彼此。
鸭子类型：
对象有类型，但是变量（包括参数）没有类型。在实践中，为对象声明的类型无关紧要，重要的是对象具体支持什么操作。
名义类型：
对象和变量都有类型。但是，对象只存在于运行时，类型检查工具只关心使用类型提示注解变量（包括参数）的源码。

例：
class Bird:
      pass
class Duck(Bird):
      def quack(self):
        print('Quack!')

def alert(birdie):
      birdie.quack()
def alert_duck(birdie: Duck) -> None:
      birdie.quack()
def alert_bird(birdie: Bird) -> None:
      birdie.quack()

>>> daffy = Duck()
>>> alert(daffy)
Quack!
>>> alert_duck(daffy)
Quack!
>>> alert_bird(daffy)
Quack!

Duck类是Bird类的子类
在运行时，Python 不关注声明的类型，仅使用鸭子类型。

例：
from birds import * 
woody = Bird() #1
alert(woody) #2
alert_duck(woody) #3
alert_bird(woody) #4

1.woody为Bird实例
2.alert(woody)，无声明，但woody无quack()方法
3.alert_duck(woody)，woody不是Duck实例，且woody无quack()方法
4.alert_bird(woody)，woody是Bird实例，但woody无quack()方法


注解中可用的类型
大部分 Python 类型可以在类型提示中使用，不过有一些限制和建议。另外，typing 模块引入的特殊结构，在语义上或许会让你惊讶。
可用于注解的所有主要类型：
*typing.Any；
*简单的类型和类；
*typing.Optional 和 typing.Union；
*泛化容器，包括元组和映射；
*抽象基类；
*泛化可迭代对象；
*参数化泛型和 TypeVar；
*typing.Protocols——静态鸭子类型的关键；
*typing.Callable；
*typing.NoReturn——就此打住比较好。

　
Any类型：
Any 类型是渐进式类型系统的基础，是人们熟知的动态类型。下面是一个没有类型信息的函数：
def double(x): 
      return x * 2
在类型检查工具看来，假定其具有以下类型信息：
def double(x: Any) -> Any: 
      return x * 2

也就是说，x 参数和返回值可以是任何类型，二者甚至可以不同。Any类型支持所有可能的操作。
以下述签名为例，对比一下 Any 和 object。
def double(x: object) -> object:
这个函数也接受每一种类型的参数，因为任何类型都是 object 的子类型。然而，类型检查工具拒绝以下函数。因为 object 不支持 __mul__ 操作。

越一般的类型，接口越狭窄，即支持的操作越少。
但是，Any 是一种魔法类型。当然，没有任何一种类型可以支持所有可能的操作，因此使用 Any 不利于类型检查工具完成核心任务，即检测潜在的非法操作，防止运行时异
常导致程序崩溃。

子类型与相容
子类型：
假有父类T1及其子类T2，T2继承T1的所有方法，但子类T2可能实现了其他方法，
相容规则如下：
01. 对 T1 及其子类型 T2，T2 与 T1 相容（里氏替换）。
02. 任何类型都与 Any 相容：声明为 Any 类型的参数接受任何类型的对象。
03. Any 与任何类型都相容：始终可以把 Any 类型的对象传给预期其他类型的参数。


简单的类型和类
Optional类型和Union类型
前例：
from typing import Optional 
def show_count(count: int, singular: str, plural: Optional[str] = None) -> str:

Optional[str] 结构其实是 Union[str, None] 的简写形式，表示 plural 的类型可以是 str 或 None。
Union[str, bytes] 可以写成 str | bytes。不用从typing模块导入Union或Optional
plural: Optional[str] = None
plural: str | None = None
| 运算符还可用于构建 isinstance 和 issubclass 的第二个参数，例如 isinstance(x, int | str)。
内置函数 ord 的签名：def ord(c: Union[str, bytes]) -> int: ...
下面示例中的函数接受一个 str，但是可以返回一个 str 或 float：
from typing import Union
def parse_token(token: str) -> Union[str, float]:
      try:
             return float(token)
      except ValueError:
             return token

Union[] 至少需要两种类型。嵌套的 Union 类型与扁平的 Union 类型效果相同。因此，
Union[A, B, Union[C, D, E]]和Union[A, B, C, D, E]作用一样
Union 所含的类型之间不应相容。


泛化容器
大多数 Python 容器是异构的。例如，在一个 list 中可以混合存放不同的类型。然而，实际使用中这么做没有什么意义。存入容器的对象往
往需要进一步处理，因此至少要有一个通用的方法。

泛型可以用类型参数来声明，以指定可以处理的项的类型。例如，可以像示例那样参数化一个 list，约束元素的类型。
例：
def tokenize(text: str) -> list[str]: 
      return text.upper().split()

stuff: list 和 stuff: list[Any] 这两个注解的意思相同，都表示 stuff 是一个列表，而且列表中的项可以是任何类型的对象。

部分容器类型及对应的类型提示：
容器                                                对应的类型提示
list                                                  typing.List
set                                                  typing.Set
frozenset                                        typing.FrozenSet
collections.deque                            typing.Deque
collections.abc.MutableSequence    typing.MutableSequence
collections.abc.Sequence                 typing.Sequence
collections.abc.Set                           typing.AbstractSet
collections.abc.MutableSet              typing.MutableSet


元组
用作记录：
元组用作记录时，使用内置类型 tuple 注解，字段的类型在 []内声明。如：('Shanghai', 24.28, 'China')，类型提示为 tuple[str, float, str]。

带有具名字段：
如果想注解带有多个字段的元组，或者代码中多次用到的特定类型的元组，强烈建议使用 typing.NamedTuple。
例：
from typing import NamedTuple
from geolib import geohash as gh  # type: ignore
PRECISION = 9
class Coordinate(NamedTuple):
      lat: float
      lon: float
def geohash(lat_lon: Coordinate) -> str:
      return gh.encode(*lat_lon, PRECISION)

用作不可变序列：
如果想注解长度不定、用作不可变列表的元组，则只能指定一个类型，后跟逗号和 ...
例如，tuple[int, ...] 表示项为 int 类型的元组。省略号表示元素的数量≥1
stuff: tuple[Any, ...] 和 stuff: tuple这两个注解的意思相同


泛化映射
泛化映射类型使用 MappingType[KeyType, ValueType] 形式注解。
例：
import sys
import re
import unicodedata
from collections.abc import Iterator
RE_WORD = re.compile(r'\w+') # 正则表达式匹配字母和数字
STOP_CODE = sys.maxunicode + 1 # 最大码点

def tokenize(text: str) -> Iterator[str]:
      """返回全大写的单词构成的可迭代对象"""
      for match in RE_WORD.finditer(text): # 匹配单词
            yield match.group().upper() # 迭代单词

def name_index(start: int = 32, end: int = STOP_CODE) -> dict[str, set[str]]:
      index: dict[str, set[str]] = {} # 键为str，值为set的字典
             for char in (chr(i) for i in range(start, end)): # 从指定码点范围迭代字符
                   if name := unicodedata.name(char, ''): # 如果name的值不为假（char有名字），进入下面的for循环
                        for word in tokenize(name): # 迭代字符串（字符的官方名称）
                              index.setdefault(word, set()).add(char) # 有则添加，无则集合
      return index

当把 dict 用作记录时，一般来说，所有键都使用 str 类型，对应的值是什么类型则取决于键的含义。

抽象基类
发送时要保守，接收时要大方    ----柏斯塔尔定律
理想情况下，函数的参数应接受那些抽象类型，而不是具体类型。这样对调用方来说更加灵活。
例：
from collections.abc import Mapping 
def name2hex(name: str, color_map: Mapping[str, int]) -> str:
由于注解的类型是 abc.Mapping，因此调用方可以提供 dict、defaultdict 和 ChainMap 的实例，UserDict 子类的实例，或者Mapping 的任何子类型。

def name2hex(name: str, color_map: dict[str, int]) -> str:
这里，color_map 必须是 dict 或其子类型，例如 defaultDict或 OrderedDict。特别注意，使用 collections.UserDict 的子
类无法通过类型检查，尽管 3.6.5 节讲过，建议扩展collections.UserDict 自定义映射。Mypy 会拒绝 UserDict 或其
衍生类的实例，因为 UserDict 不是 dict 的子类，二者是同级关系，都是 abc.MutableMapping 的子类。

函数的返回值的类型提示始终应该是一个具体对象
注解数字参数由以下几种选择：
1.使用int，float或complex中的某个具体类型
2.声明一种联合类型，例如Union[float, Decimal, Fraction]
3.使用SupportsFloat等数字协议


Iterable
例：
from collections.abc import Iterable
FromTo = tuple[str, str]
def zip_replace(text: str, changes: Iterable[FromTo]) -> str:
      for from_, to in changes:
            text = text.replace(from_, to)
      return text

FromTo是类型别名，changes的类型为Iterable[FromTo]，与Iterable[tuple[str, str]]一样
“PEP 613—Explicit Type Aliases”引入了一种特殊类型，即TypeAlias，以让创建类型别名的赋值操作更显眼，也让类型检查
更容易。从 Python 3.10 开始，创建类型别名的首选方式如下所示。
from typing import TypeAlias 
FromTo: TypeAlias = tuple[str, str]


参数化泛型和TypeVar
参数化泛型是一种泛型，写作 list[T]，其中 T 是类型变量，每次使用时会绑定具体的类型。这样可在结果的类型中使用参数的类型。
例：
from collections.abc import Sequence
from random import shuffle
from typing import TypeVar
T = TypeVar('T')
def sample(population: Sequence[T], size: int) -> list[T]:
      if size < 1:
         raise ValueError('size must be >= 1')
      result = list(population)
      shuffle(result)
      return result[:size]

T为推导类型，第一个类型T可以是任何类型，后面的类型T与第一个T类型一致

受限的TypeVar
TypeVar接受一些位置参数，以对类型参数施加限制
例：
NunberT= TypeVar('NumberT', float, Decimal, Fraction)

有界的TypeVar
bound关键字参数为可接受的类型设定一个上边界
例：
HashableT = TypeVar('Hashable', bound=Hashable)
使用bound=Hashable指明，类型参数可以是Hashable或它的任何子类型

预定义的类型变量AnyStr
例：
AnyStr = TypeVar('AnyStr', bytes, str)


静态协议











